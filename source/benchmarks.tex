%==============================================================================
% benchmarks.tex
%==============================================================================

\chapter{Benchmarks}
\label{chap:appendix-benchmarks}

\section{Java Grande Forum}
\label{sec:benchmarks-jgf}

We evaluate the \emph{intervals} work-stealing queues on a variety of
parallel Java Grande Forum benchmarks \cite{Smith2001, Mathew1999,
  Gregg2003} ported to use \emph{intervals}.

The JVM used on both machines described in appendix
\ref{chap:experimental-setup} is Sun Hotspot JDK 1.6. In both cases,
the JVM was invoked with the following parameters:

\begin{verbatim}
    -server -Xmx2048M -Xms2048M -Xss8m
\end{verbatim}

\subsection*{Crypt}

Crypt performs IDEA (International Data Encryption Algorithm)
encryption and decryption of an array of $N$ bytes. This algorithm
involves two principle loops, whose iterations are independent and are
divided using fork-join sections between \emph{intervals} in a block fashion.

\subsection*{LUFact}

This benchmark solves an $N \times N$ linear system using LU factorization
followed by a triangular solve. Iterations of the double loop over the
trailing block of the matrix are independent and the work is divided
between \emph{intervals} in a cyclic fashion using fork-join sections.

\subsection*{SOR}

The benchmark performs iterations of successive over-relaxations on a
$N \times N$ grid. It involves an outer loop over iterations and two
inner loops, each looping over the grid. In order to parallelize the
loop over array rows, a ``red-black'' ordering mechanism is used. The
work is distributed between \emph{intervals} in a block manner with
help of point-to-point synchronization.

\subsection*{Series}

This benchmark computes the first $N$ fourier coefficients of the
function $f(x) = (x+1)^x$ on the interval $0,2$. It uses fork-join
sections to distribute the loop over the Fourier coefficients between
\emph{intervals}.

\subsection*{MolDyn}

The MolDyn benchmark models particles interacting under a
Lennard-Jones potential in a cubic spatial volume with periodic
boundary conditions. The calculation is distributed between
\emph{intervals} in a cyclic manner and synchronization is done using
barriers.

\subsection*{MonteCarlo}

This benchmark is a financial simulation, using Monte Carlo techniques
to price products derived from the price of an underlying asset. The
work is divided between \emph{intervals} by using fork-join sections.

\subsection*{RayTracer}

This benchmark measures the performance of a 3D ray tracer rendering a
scene containing 64 spheres at a resolution of $N \times N$
pixels. The loop over rows of pixels has been distributed to
\emph{intervals} using fork-join sections.


\section{Locality-Aware Benchmarks}

We evaluate the locality-aware implementation of \emph{intervals} on a
variety of benchmarks. To reduce the impact of JVM overheads in the
evaluation, including JIT compilation and garbage collection, the
execution time reported is the average of the three best benchmark
iterations from three seperate VM incocations. Each VM invocation
performs 10 benchmark iterations.

The JVM used on both machines described in appendix
\ref{chap:experimental-setup} is Sun Hotspot JDK 1.6. In both cases,
the JVM was invoked with the following parameters:

\begin{verbatim}
    -server -Xmx4096M -Xms4096M -Xss8m -XX:+UseNUMA
\end{verbatim}

The following benchmarks were first written to use threads and then
ported over to use \emph{intervals}.

\subsection*{Cache-Stress Test}

\todo[inline]{Describe benchmark ``Cache-Stress Test''}

\subsection*{Merge Sort}

\todo[inline]{Describe benchmark ``Merge Sort''}

\subsection*{Block Matrix Multiplication}

\todo[inline]{Describe benchmark ``Block Matrix Multiplication''}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 