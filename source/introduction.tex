%==============================================================================
% introduction.tex
%==============================================================================

\chapter{Introduction}
\label{chap:introduction}

\section{Intervals}
\label{sec:intro-intervals}

Intervals \cite{Matsakis2009b} are a new, higher-level primitive for
parallel programming with which programmers directly construct the
program schedule. They are under active development at ETH ZÃ¼rich as
part of the PhD research of Nicholas Matsakis \cite{Matsakis2010}.

Existing primitives for synchronizing the control-flow of parallel
threads, such as signals and barriers, are low-level and dangerous to
use. They require careful attention to implementation details to
achieve good performance, and they are prone to errors, particularly
deadlocks and race conditions.

Intervals are a higher-level alternative that make parallel
programming safer while retaining the flexibility and efficiency of
threads. In the Intervals model, users create lightweight tasks and
order them using explicit \emph{happens before} relations
\cite{Lamport1978}. Users need not specify when a thread should block
or acquire a lock. Instead they specify when a task should execute
relative to other tasks, and what locks it should hold when it
executes. The details of making this schedule pass are left to the
runtime system.

The intervals API supports arbitrary \emph{happens before} relations
making the model very flexible. Intervals can be used to emulate
existing thread primitives \cite{Matsakis2009b}, but they can also be
used to easily create program schedules for which no standard thread
primitives exist, such as peer-to-peer synchronization.

One of the primary goals in developing intervals is that program
errors should not lead to deadlocks. This includes both misuse of the
APIs but also miscellaneous errors which causes tasks to abort
unexpectedly, such as dereferencing a null pointer
\cite{Matsakis2009}. A further goal is that an error in one task
should prevent other, dependent tasks from executing
\cite{Matsakis2010a}.

\subsection{Related Work}
\label{sec:intro-intervals-related-work}

\todo[inline]{Related work}

\subsection{Model}
\label{sec:intro-intervals-model}

Intervals are first-class objects in the programming language that
represent the slice of program time used to execute a parallel
task. Intervals are structured hierarchically in a tree. The root of
the interval tree represents the entire program execution. Program
execution itself begins in a child of the root interval.

The conceptual model for intervals consists of points in time ordered
by a \emph{happens before} relation. In the model, an interval
\lstinline|i| consists of a pair of points -- \lstinline|i.start| and
\lstinline|i.end| -- called the start and end point. The start point
represents the moment when the interval begins execution. The end
point represents the moment when the interval's task is
completed. Programmers may introduce arbitrary ordering constraints by
adding \emph{happens before} edges between the start or end points of
different intervals. An edge \lstinline|p1 $\rightarrow$ p2| indicates
that the point \lstinline|p1| must occur before the point
\lstinline|p2|. It also indicates that any memory writes which
\emph{happen before} \lstinline|p1| must be visible to \lstinline|p2|.

An interval can be associated with one or more locks. The intervals
runtime will automatically acquire those locks before the interval's
start point occurs and release them after its end point has occurred.

When an interval executes, it begins by invoking the sequential method
\lstinline|run()|. \lstinline|run()| may either perform the task
directly or create a number of subintervals to achieve the task in
parallel. These subintervals begin to execute once the
\lstinline|run()| method has completed and they are ready to run. A
subinterval is ready to run when it could execute without violating
the \emph{happens before} relation. It will be executed when it is
ready and acquired all its locks.

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.96\textwidth]{introduction/interval-graph}
  \caption[Example interval graph]{Example interval graph: Showing an
    interval and its subintervals \lstinline|a|, \lstinline|b|,
    \lstinline|c| and \lstinline|d|.}
  \label{fig:interval-graph}
\end{figure}

The interval model can be depicted as a graph, as shown in Figure
\ref{fig:interval-graph}. The graph contains a single interval with
four subintervals, \lstinline|a|, \lstinline|b|, \lstinline|c| and
\lstinline|d|. The start and end points of each interval are
represented as opaque circles. The subintervals of an interval are
enclosed in a dashed box. This dashed box is omitted for leaf
intervals.

The dashed edges connecting different points indicate user-specified
additions to the \emph{happens before} relation. For example, the end
of \lstinline|a| \emph{happens before} the start of \lstinline|b| and
\lstinline|c| and the ends of \lstinline|b| and \lstinline|c| both
\emph{happen before} the start of \lstinline|d|.

\subsection{Java API}
\label{sec:intro-intervals-java-api}

In the Java API, intervals are represented as instances of the
abstract class \lstinline|Interval| (Listing
\ref{lst:interval-class}). \lstinline|Interval| provides immutable
fields to access the interval's start point, end point, and parent,
along with an abstract \lstinline|run()| method which must be
redefined in a concrete subtype.

\begin{lstlisting}[
  style=Float, 
  caption={[\lstinline{Interval} class] \lstinline{Interval}: Serves as the base class for all intervals},
  label=lst:interval-class
]
public abstract class Interval {
  public final Interval parent;
  public final Point start;
  public final Point end;

  protected abstract void run();
}
\end{lstlisting}

Listing \ref{lst:interval-graph} contains Java code which uses the
Intervals API to construct the graph shown in Figure
\ref{fig:interval-graph}.

\begin{lstlisting}[
  style=Float, 
  caption={[Intervals Java API example] Code to produce the sample interval graph shown in Figure \ref{fig:interval-graph}},
  label=lst:interval-graph
]
public class ExampleInterval extends Interval {
  public ExampleInterval(Dependency dep, String name) {
    super(dep, name);
  }
  
  protected void run() {
    // Task
  }
  
  public static void main(String[] args) {
    Intervals.inline(new VoidInlineTask() { //*\label{lst:interval-graph-inline-start}
      public void run(Interval start) {
        Interval a = new ExampleInterval(start, "a"); //*\label{lst:interval-graph-new-start}
        Interval b = new ExampleInterval(start, "b");
        Interval c = new ExampleInterval(start, "c");
        Interval d = new ExampleInterval(start, "d"); //*\label{lst:interval-graph-new-end}
        
        Intervals.addHb(a, b); //*\label{lst:interval-graph-add-hb}
        Intervals.addHb(a, c);
        Intervals.addHb(b, d);
        Intervals.addHb(c, d);
        Intervals.schedule(); //*\label{lst:interval-graph-schedule}
      }
    }); //*\label{lst:interval-graph-inline-end}
  }
}
\end{lstlisting}

\subsubsection{Creating Intervals}
\label{sec:intro-intervals-creating-intervals}

To start program execution, the programmer has to create a new child
of the root interval. One could for example use an inline interval to
do so. Inline intervals execute a task during the current interval and
do not return until the task has completed.

Lines \ref{lst:interval-graph-inline-start} --
\ref{lst:interval-graph-inline-end} create the inline subinterval
\lstinline|start| by providing an anonymous task class redefining its
\lstinline|run()| method. \lstinline|start| has four subintervals,
\lstinline|a|, \lstinline|b|, \lstinline|c| and \lstinline|d|. They
are created on lines \ref{lst:interval-graph-new-start} --
\ref{lst:interval-graph-new-end} and are normal, non-blocking
intervals.

\subsubsection{Scheduling Intervals}
\label{sec:intro-intervals-scheduling-intervals}

Newly constructed intervals become eligible for execution once the
\lstinline|schedule()| method is invoked, as shown on line
\ref{lst:interval-graph-schedule} in Listing
\ref{lst:interval-graph}. This gives the user the opportunity to
construct any required dependencies or perform other
initialization. For example, adding the edge
\lstinline|a $\rightarrow$ b| on line \ref{lst:interval-graph-add-hb}
would be unsafe if \lstinline|b| could begin immediately, as it would
be possible that \lstinline|b.start| had already occurred before the
call to \lstinline|addHb()| could add the new dependency.

Explicit calls to \lstinline|schedule()| are unusual, however. This is
because the runtime automatically invokes \lstinline|schedule()| when
the \lstinline|run()| method of an interval returns.


\section{Work-stealing Scheduler}
\label{sec:intro-work-stealing-scheduler}

\todo[inline]{Finish description of work-stealing scheduler}

The implementation of Intervals for Java makes use of a work-stealing
scheduler similar to those found in Cilk \cite{Blumofe1995} or Java 7
\cite{Lea} but extended to support locks and happens before
edges. Each worker is implemented as a separate Java thread. The JVM
used to benchmark the implementation is Sun Hotspot JDK 1.6 (see
Appendix \ref{chap:experimental-setup} for information of the
experimental setup).

\todo{Incorporate literature review in text}

\subsection{Literature Review}
\label{sec:intro-work-stealing-literature-review}

\subsubsection{Work-stealing Scheduler}

\begin{itemize}
\item Work stealing: an annotated bibliography \cite{Neill2001}
\item The Performance of Work Stealing in Multiprogrammed Environment
  \cite{Blumofe1998a}
\item Scheduling multithreaded computations by work stealing
  \cite{Blumofe1999}
\item Space efficient execution of deterministic parallel programs
  \cite{Simpson1999}
\item Lazy binary-splitting: a run-time adaptive work-stealing
  scheduler \cite{Tzannes2010}
\item Mely: Efficient Workstealing for Multicore Event-Driven Systems
  \cite{Gaud2010}
\end{itemize}

\subsubsection{Libraries and Languages Using Work-stealing Scheduling}

\begin{itemize}
\item Helper locks for fork-join parallel programming
  \cite{Agrawal2010}
\item Cilk: An efficient multithreaded runtime system
  \cite{Blumofe1995}
\item Hood: A user-level threads library for multiprogrammed
  multiprocessors \cite{Blumofe1998}
\item X10: an object-oriented approach to non-uniform cluster
  computing \cite{Charles2005}
\item Report on the programming language X10 \cite{Saraswat2010}
\item Characterizing and improving the performance of intel threading
  building blocks \cite{Contreras2008}
\item Wool-a work stealing library \cite{Faxen2009}
\item The implementation of the Cilk-5 multithreaded language
  \cite{Frigo1998}
\item A Java fork/join framework \cite{Lea2000}
\item Fork / Join Parallelism in Java \cite{Lea2000a}
\item Concurrency JSR-166 Interest Site \cite{Lea}
\item Efficient support for fine-grain parallelism on shared-memory
  machines \cite{Lowenthal1998}
\item Hood: A User-Level Thread Library for Multiprogramming
  Multiprocessors \cite{Papadopoulos1998}
\item Compiler Support for Work-Stealing Parallel Runtime Systems
  \cite{Raman2009}
\item Intel threading building blocks: outfitting C++ for multi-core
  processor parallelism \cite{Reinders2007}
\item StackThreads/MP: Integrating futures into calling standards
  \cite{Taura1999}
\end{itemize}


\section{Overview}
\label{sec:intro-overview}

\todo[inline]{Finish overview}

The intervals implementation in Java uses a work-stealing scheduler in
which a worker that runs out of work tries to ``steal'' work from
others. The goal of this thesis is to improve the efficiency of the
intervals scheduler.

\subsubsection*{Part \ref{part:queues}. Explore and profile different
  work-stealing queue implementations}

In a work-stealing scheduler, each worker keeps a pool of work items
waiting to be executed. The current intervals implementation uses
doubled-ended queues (deque).  

In the first part of this thesis we explored alternative queue
implementations and compared them to the current implementation.

\subsubsection*{Part \ref{part:locality}. Locality-aware
  work-stealing}

Currently the intervals scheduler randomly schedules work items and
when stealing a work item, the worker chooses his victim by random. To
improve performance and reduce cache misses, work items that access
the same data should be scheduled on the same worker or a worker
``nearby''.

In the second part of the thesis we implemented and analyzed
locality-aware scheduling of intervals. In locality-aware scheduling,
each interval can be given an affinity for a place, and when a worker
belonging to a certain place obtains an interval, it gives priority to
the intervals with affinity for the place.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
